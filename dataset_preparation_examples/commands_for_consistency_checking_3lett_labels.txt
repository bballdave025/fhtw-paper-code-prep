Get root of all classified names, then use `find` from the base
FHTW-2025-blah-blah to do a find on each. If the number returned
is only 1, output (tee) to a problem file. If it's found, maybe
put it in a matched file, or maybe just leave it.
Search from Base should not include "*.jpg" part

Also check for duplicate roots.

#
######## GETTING ALL CANDIDATE CLASSIFICATIONS THAT FOLLOW 
######## THE 3-LETTER PART OF NAMING RULES
####BEGIN <1>#############################################################
# For any directory, get the underscore-linked 3lett
#
###  For the following command, just take off the (`uniq -c) to get
###  all candidates for all filenames (probably want to append
###  ` | wc -l` count
$ # COUNT OF NOT-UNIQ-ED LIST, (`wc -l`) count and (`-c`) COUNT
$ find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_[a-z]\{3\}\)\+[.]jpg$" | \
      sed 's#[.]jpg$##g' | \
        sort | uniq -c | \
   wc -l




## GOOD HERE. Get all three-letters-rule 3-letter things,
$ find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_[a-z]\{3\}\)\+[.]jpg$" | \
      sed 's#[.]jpg$##g' | \
        tr '_' '\n' | tr -s '\n' | awk 'NF' | \
        sort | uniq -c | wc -l

$ find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_[a-z]\{3\}\)\+[.]jpg$" | \
      sed 's#[.]jpg$##g' | \
        tr '_' '\n' | tr -s '\n' | awk 'NF' | \
        sort | uniq -c | sort -rn

$ find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_[a-z]\{3\}\)\+[.]jpg$" | \
      sed 's#[.]jpg$##g' | \
        tr '_' '\n' | tr -s '\n' | awk 'NF' | \
        sort | uniq -c | sort -rn | \
      awk '{ sum += $1 }; END {print sum}'

#  For those with only one classification:
$ find . -type f -iname "*.jpg" | awk -F'/' '{print $NF}' | \
    grep -P \
      '(?<!(abg|cwa|fko|fmr|gni|iac|mbr|mcl|mmx|'\
'nbr|oic|orc|scg|spr|suh|tbr|ucr))_'\
'(abg|cwa|fko|fmr|gni|iac|mbr|mcl|mmx|'\
'nbr|oic|orc|scg|spr|suh|tbr|ucr)[.]jpg$' | \
      wc -l  # could head or tail it - full file names
2021
#  Get just the one classification, sorted uniq C count
$ find . -type f -iname "*.jpg" | awk -F'/' '{print $NF}' | \
    grep -oP \
      '(?<!(abg|cwa|fko|fmr|gni|iac|mbr|mcl|mmx|'\
'nbr|oic|orc|scg|spr|suh|tbr|ucr))_'\
'(abg|cwa|fko|fmr|gni|iac|mbr|mcl|mmx|'\
'nbr|oic|orc|scg|spr|suh|tbr|ucr)[.]jpg$' | \
       awk -F'.' '{print $1}' | tr -d '_' | \
       sort | uniq -c | sort -rn

#  I'm getting good at printing out a bunch of filenames 
#+ (thousands of them). Let's put in all the line continuers ('\')

#  Get all the 3lett from f25a3, one per line
$ echo "$(f25a3)" | tr '\\' '\n' | tr -d ')(|' | awk 'NF'

#  Get just the unique 3lett
$ find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_[a-z]\{3\}\)\+[.]jpg$" | \
      sed 's#[.]jpg$##g' | \
        tr '_' '\n' | tr -s '\n' | awk 'NF' | \
        sort | uniq


$ # UNIQ LIST WITH (`wc -l`) COUNT 
$ find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_[a-z]\{3\}\)\+[.]jpg$" | \
      sed 's#[.]jpg$##g' | \
        sort | uniq -c | \
   wc -l
$ # UNIQ LIST (`-c` COUNT), SHOWING ALL OF THEM
$ find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_[a-z]\{3\}\)\+[.]jpg$" | \
      sed 's#[.]jpg$##g' | \
        sort | uniq -c | sort -rn

#+ other of the additions below can be tagged on (like getting
#+ unique sorted combinations of legal-at-least-having-three-letters-rule
#+ classifications.

#  Doing this either yesterday (2025-07-24) or the day before,
#+ I found a few mispellings, one filename that had 'max' (as
#+ in maxCopy or maxRes without the second part, and one other
#+ thing that needed changing, I believe.
####ENDOF <1>#######(all candidate classifications following 3lett rule###

######## GETTING ALL CLASSIFICATIONS THAT FOLLOW NAMING RULES ############
####BEGIN <2>#############################################################
#+ For any directory, get all rule-following 3lett ...
######BEGIN <2.1>#########################################################
#+ ... start by get all the underscore-linked 3lett (with no `uniq`)
$ #
#  (`wc -l`) COUNT (for this one, you ONLY want to do the (`wc -l`) 
#+ count (unless you want classification part of ####ALL#### files) - 
#+ just added ` | wc -l`
$ find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_\(abg\|cwa\|fko\|fmr\|gni\|iac\|mbr\|mcl\|"\
"mmx\|nbr\|oic\|orc\|scg\|spr\|suh\|tbr\|ucr\)\)\+" | \
        sed 's#[.]jpg$##g' | sort | \
   wc -l
$ #
#  COUNT NUMBER OF almost-UNIQUE COMBINATIONS (this is not the place
#+ We don't have to do that here, as there isn't a fixed order.
#+ Later, we'll alphabetically sort the classes and find unique combos)
$ find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_\(abg\|cwa\|fko\|fmr\|gni\|iac\|mbr\|mcl\|"\
"mmx\|nbr\|oic\|orc\|scg\|spr\|suh\|tbr\|ucr\)\)\+" | \
        sed 's#[.]jpg$##g' | sort | uniq -c | \
   wc -l  # Probably skip this. Might want `uniq` without `-c`.
#                               Might want without `uniq -c` (match n_files)
#                               Might want pipe to `uniq -rn`
#
######ENDOF <2.1>#########(all name-rule-following 3lett undsc-linked)####
#
######BEGIN <2.2>#########################################################
$ ####
####  COUNT NUMBER OF UNDERSCORE-LESS CLASS COMBINATIONS (PRE COMBO SORT)
####+ (IF THIS NUMBER ISN'T TO BIG
$ 
$ #  GET THE UNIQUE, UNDERSCORE-LESS, PRE-COMBO-SORT COMBINATIONS
$ #+  COUNT first (`wc -l` COUNT)
$ ttdate && \
time \
  find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_\(abg\|cwa\|fko\|fmr\|gni\|iac\|mbr\|mcl\|"\
"mmx\|nbr\|oic\|orc\|scg\|spr\|suh\|tbr\|ucr\)\)\+" | \
        sed 's#[.]jpg$##g' | \
        tr -s '_' | \
        sed 's#^_##g; s#_$##g' | \
        tr _ ' ' | \
        sort | uniq | \
   wc -l \
 && ttdatechk
$ ####
####  THIS NEXT ONE IS ONE YOU ACTUALLY MIGHT _NOT_ WANT TO SKIP THE
####+ OUTPUT, DUE TO THE FACT THAT IT WILL
####+ SHOW THE almost-UNIQUE CLASSIFICATION PART OF FILES 
####+ (W/O UNDERSCORES)
#  SHOW (IF THE COUNT ISN'T TOO CRAZY) - REM. THIS IS PRE-COMBO-SORT
#+ (MEANING THERE COULD STILL BE, e.g. 'mcl ucr' and 'ucr mcl' showing
#+ up differently)
$ ttdate && \
time \
  find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_\(abg\|cwa\|fko\|fmr\|gni\|iac\|mbr\|mcl\|"\
"mmx\|nbr\|oic\|orc\|scg\|spr\|suh\|tbr\|ucr\)\)\+" | \
        sed 's#[.]jpg$##g' | \
        tr -s '_' | \
        sed 's#^_##g; s#_$##g' | \
        tr _ ' ' | \
        sort | uniq \
 && ttdatechk
$ #
#  Same, but with number (i.e. `-c` count) of each 
#+ pre-combo-sort combinations
$ ttdate && \
time \
  find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_\(abg\|cwa\|fko\|fmr\|gni\|iac\|mbr\|mcl\|"\
"mmx\|nbr\|oic\|orc\|scg\|spr\|suh\|tbr\|ucr\)\)\+" | \
        sed 's#[.]jpg$##g' | \
        tr -s '_' | \
        sed 's#^_##g; s#_$##g' | \
        tr _ ' ' | \
        sort | uniq -c | sort -rn \
 && ttdatechk
$
$ # LIST UNIQUE COMBO-SORTED COMBINATIONS OF LEGAL CLASS COMBOS
### THIS COMMAND IS LIKELY MORE EFFICIENT AND USEFUL IF YOU USE
### INTERMEDIARY FILES
#  Now, without the `wc -l` option (you can do that yourself),
#+ the combination sort, e.g. 'mcl ucr' and 'ucr mcl' will both
#+ become `mcl urc` and won't be considered or grouped separately.
#+ note that taking out the `bash -c` for the first  xargs
#+ (i.e. doing   `xargs -I'{}' -0 echo "{}" | xargs -n1 | sort | xargs` )
#+ will result in a list with one word on each line. To get the
#+ whole combination of labels, keep in the `bash -c`
$ ttdate && \
time \
  find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_\(abg\|cwa\|fko\|fmr\|gni\|iac\|mbr\|mcl\|"\
"mmx\|nbr\|oic\|orc\|scg\|spr\|suh\|tbr\|ucr\)\)\+" | \
        sed 's#[.]jpg$##g' | \
        tr -s '_' | \
        sed 's#^_##g; s#_$##g' | \
        tr _ ' ' | \
          tr '\n' '\0' | \
          xargs -I'{}' -0 bash -c \
          'orig="{}"; echo "${orig}" | xargs -n1 | sort | xargs' \
            sort | uniq \
 && ttdatechk
#      Might want         `uniq -c`
#      Might want without `uniq` (match n_files), but use `wc -l`
#      Might want pipe `uniq -c` to `uniq -rn`
$     #
#  creating intermediary lists of results can cut computational time
#+ due to not spawning sub-shells.
#+ 
#################################################
#  With intermediary files, complete to uniq 
#+ with freq
#+ 
$ my_ts=$(ttdate)  # Keep this timestamp with all files 
$ ttdate && \
  time \
find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_[a-z]\{3\}\)\+[.]jpg$" | \
      sed 's#[.]jpg$##g' | \
        sort | uniq \
   > undrscr_linkd_3lett_candidates_uniq_${my_ts}.lst
 && ttdatechk
$ #
#  Show that we get pairs of really-unique classifications with differing
#+ order of labeling
$ #  Example to show process (now done manually)
$ grep -P \
  "(_fko_(cwa|fmr|gni|nbr|orc|scg|spr|tbr|ucr))|(_\2_fko)" \
    undrscr_linkd_3lett_candidates_uniq_${my_ts}.lst | wc -l
17
$ $ grep -P \
  "(_fko_(cwa|fmr|gni|nbr|orc|scg|spr|tbr|ucr))|(_\2_fko)" \   undrscr_linkd_3lett_candidates_uniq_undrscr_linkd_3lett_candidates_uniq_${my_ts}.lst.lst

$ grep "_fko_fmr\|_fmr_fko" \
    undrscr_linkd_3lett_candidates_uniq_1753507300_2025-07-25T232140-0600.lst | wc -l

$ #
#  The `time` at the beginning of each following commands, along with 
#+ the `ttdate` and `ttdatechk`, are not
#+ necessary, but I use it to do my own comparisons.
$ ttdate && \
time \
  find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_\(abg\|cwa\|fko\|fmr\|gni\|iac\|mbr\|mcl\|"\
"mmx\|nbr\|oic\|orc\|scg\|spr\|suh\|tbr\|ucr\)\)\+" | \
      sed 's#[.]jpg$##g;' > \
   all_undrscr_linked_legal_label_combos_${my_ts}.lst \
 && ttdatechk
$ ttdate && \
  time \
tr -s '_' < \
    all_undrscr_linked_legal_label_combos_${my_ts}.lst | \
      sed 's#^_##g; s#_$##g' | \
        tr '_' ' ' > \
   all_space_sep_legal_label_combos_${my_ts}.lst \
 && ttdatechk
$ ttdate && \
  time \
tr '\n' '\0' < \
    all_space_sep_legal_label_combos_${my_ts}.lst | \
      xargs -I'{}' -0 bash -c '
        orig="{}"
        echo "${orig}" | xargs -n1 | sort | xargs
      ' | sort | uniq -c | sort -rc | \
   tee uniq_combo_sorted_legals_${my_ts}.lst \
 && ttdatechk
#    Might want `uniq` (without `-c`)
#    Might want without `uniq` (match n_files), but use `wc -l`
#    Might want to see without piping `uniq -c` to `uniq -rn`
#  Useful to add ' | tee uniq_combo_sorted_count_legals_${my_ts}.lst'
#+ with the original ` | uniq -c | sort -rc`
#  This also gives you starting points for other pipelines that you'll
#+ have to reason out on your own.
#

# For debugging what's above
ttdate && \
  time \
find . -type f -iname "*.jpg" | \
  awk -F'/' '{print $NF}' | \
  grep "_abg" | \
\# that last line was the problem #
  grep -io "\(_[a-z]\{3\}\)\+[.]jpg$" | \
  sed 's#[.]jpg$##g' | \
    tr -s '_' | sed 's#^_##g; s#_$##g' | tr _ ' ' | \
      tr '\n' '\0' | \
      xargs -I'{}' -0 bash -c '
        orig="{}"; \
        echo "${orig}" | xargs -n1 | sort | xargs
      ' \
 && ttdatechk

##### -v- The final 1bigccommand -v- #####
$ ttdate &&\
  time \
find . -type f -iname "*.jpg" | \
  awk -F'/' '{print $NF}' | \
  grep -io "\(_[a-z]\{3\}\)\+[.]jpg$" | \
  sed 's#[.]jpg$##g' | \
  tr -s '_' | sed 's#^_##g; s#_$##g' | tr _ ' ' | \
    tr '\n' '\0' | \
    xargs -I'{}' -0 bash -c '
      orig="{}"; \
      echo "${orig}" | xargs -n1 | sort | xargs
    ' | sort | uniq | \
   tee uniq_combo_1bigcmd_sorted_legals_${my_ts}.lst \
 && ttdatechk

<strike>
##### -v- NOTE: just the last step of the -v- #####
ttdate && \
  time \
tr '\n' '\0' < \
  all_space_sep_legal_label_combos_${my_ts}.lst | \
    xargs -I'{}' -0 bash -c '
        orig="{}"
        echo "${orig}" | xargs -n1 | sort | xargs
    ' | sort | uniq -c | \
   tee uniq_c_combo_sorted_legals_${my_ts}.lst \
 && ttdatechk
</strike>


#
#
#+ Search for the 3lett in legal naming, count, then compare to
#+ a simple search, count. Compare the countings. Find reasons for
#+ any acceptable discrepancies. Fix/check out the others.
#
#+   Not necessarily from the same base search, but maybe hinted at by
#+   the count compare
#+ Look for any not 3lett after a one-legal 3lett (there could be doc 
#+ names, but every one of them should be accounted for)
#
######## GETTING ALL NAME-RULE-FOLLOWING CLASSIFICATIONS W/1 OF 'f25m3'
#+ Very closely related to just-follow-naming-rules, but not the same search

######## A VERY GOOD CONSISTENCY CHECK
#  1. Get a list of all downloaded filenames, with only the filename base
#+    and the to-be-stripped extension.
#+ 2. Strip the extension. This gives us BIG (filename roots)
#+ 3. Get a list of all the  filies in the dataset
#+ 4. Strip off fully legal 3lett combos (with extension)
#+ 5. This gives us DS (dataset's filename roots)
#+ 6. Find those in DS but not in BIG. There should
#+    theoretically be zero. Any that we find likely
#+    have a classification typo or inconsistent filename base
#+ 7. When you have done all checks and get 0 for
#+ 8. $ comm -13 file_BIG file_DS | wc -l
#+    Then you're ready to check for all of the files which
#+    can be considered in-the-wild.
#+    $ #WILD=$(comm -23 file_BIG file_DS)
#+    $ Probably easier to do
$_    $ comm -23 file_BIG file_DS > all_in_the_wild_possibilities_${my_tw}.lst


##########################################################################
########    MULTIPLE CLASSES stuff
#+ For any directory (the directory with everything sorted or any of the
#+ single directories), get all the `mcl` entries. (point the 0th)
#+ With the underscores and legal classifications. PROBABLY DO ` | wc -l`
$ find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_\(abg\|cwa\|fko\|fmr\|gni\|iac\|mbr\|mcl\|"\
"mmx\|nbr\|oic\|orc\|scg\|spr\|suh\|tbr\|ucr\)\)\+[.]jpg$" | \
      sed 's#[.]jpg$##g' | \
        grep "mcl"
#+ These should all either:
#+   1. Have one and only one yes-binary-model classification, 'f25m3'.
#+      in which case there should not be an 'mbr'
#+ # FIND ANY WITH MORE THAN ONE CLASSIFICATION (and no 'mbr') (BAD)
 $ find . -type f -iname "*.jpg" | \
     awk -F'/' '{print $NF}' | \
       grep -io "\(_\(abg\|cwa\|fko\|fmr\|gni\|iac\|mbr\|mcl\|"\
"mmx\|nbr\|oic\|orc\|scg\|spr\|suh\|tbr\|ucr\)\)\+[.]jpg$" | \
       sed 's#[.]jpg$##g' | \
         grep "mcl" | grep -v "mbr" |
           grep -P '(?<!_(cwa|fmr|gni|nbr|orc|scg|spr|tbr|ucr))'\
'(cwa|fmr|gni|nbr|orc|scg|spr|tbr|ucr)'\
'(?=_(cwa|fmr|gni|nbr|orc|scg|spr|tbr|ucr))'
 $ #
 #  FIND THE ONE AND ONLY ONE SINGLE CLASSIFICATION 
 #+ (with no 'mbr') (GOOD)
 $ find . -type f -iname "*.jpg" | \
     awk -F'/' '{print $NF}' | \
       grep -io "\(_\(abg\|cwa\|fko\|fmr\|gni\|iac\|mbr\|mcl\|"\
"mmx\|nbr\|oic\|orc\|scg\|spr\|suh\|tbr\|ucr\)\)\+[.]jpg$" | \
       sed 's#[.]jpg$##g' | \
         grep "mcl" | grep -v "mbr" |
           grep -P '(?<!_(cwa|fmr|gni|nbr|orc|scg|spr|tbr|ucr))'
'_(cwa|fmr|gni|nbr|orc|scg|spr|tbr|ucr)'\
'(?!_(cwa|fmr|gni|nbr|orc|scg|spr|tbr|ucr))' \
           
 $ # FIND THOSE WITHOUT ACCOMPANYING SINGLE (and no 'mbr')
 $ find . -type f -iname "*.jpg" | \
     awk -F'/' '{print $NF}' | \
       grep -io "\(_\(abg\|cwa\|fko\|fmr\|gni\|iac\|mbr\|mcl\|"\
"mmx\|nbr\|oic\|orc\|scg\|spr\|suh\|tbr\|ucr\)\)\+[.]jpg$" | \
       sed 's#[.]jpg$##g' | \
         grep "mcl" | grep -v "mbr" | \
         grep -v "\(cwa\|fmr\|gni\|nbr\|orc\|scg\|spr\|tbr\|ucr\)" 
#+   2. Have 'mbr' and more than one yes-binary-model classification.
#+   (NOTE TO SELF: JUST GO TO THE MBR SECTION FOR THESE, AFTER CHECKING
#+    THAT ALL THE 'mcl's satisfy either 1 or 2)
  $ # FIND ANY THAT HAVE 'mbr', NO MATTER WHAT ELSE (GOOD|BAD)
  $ 
  $ # FIND ANY THAT DO NOT HAVE ANY 
  $ # FIND THE OTHER SINGLE(S) (NO MATTER WHAT ELSE) (GOOD|BAD)
  $
  $ # FIND THE OTHER SINGLES (WHEN THERE ARE AT LEAST TWO) (GOOD)
  $ find . -type f -iname "*.jpg" | \
      awk -F'/' '{print $NF}' | \
        grep -io "\(_[a-z]\{3\}\)\+[.]jpg$" | \
        sed 's#[.]jpg$##g' | \
          grep "mcl" | grep 'mbr' | \
          
 $ # FIND THE OTHER SINGLE (WHEN ONLY ONE SINGLE) (BAD)
 $
#+   What else is expected?
#+     
#+   What else is allowed?
#+     3. 'fko', 'iac', and 'suh' can always be there
#+     4. 'abg' can be there 
#+   What is not allowed?
#+     5. 'nbr', 'oic', 'mmx'
#+     6. just the 'mcl' alone
#+   7. Have only one of 'f25m3'
 $ # FIND THE ONE (GOOD)
 $ find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_[a-z]\{3\}\)\+[.]jpg$" | \
      sed 's#[.]jpg$##g' | \
        grep "mcl" | grep -v 'mbr' \
$ # FIND OUT IF THERE ARE MORE THAN ONE (BAD
#+   What else is expected?
#+     
#+   What else is allowed?
#+     3. 'fko', 'iac', and 'suh' can always be there
 
#+     4. 'abg' can be there 
#+   What is not allowed?
#+     5. 'nbr', 'oic', 'mmx'
#+     6. just the 'mcl' alone
#  For any directory (the directory with everything sorted or any of the
#+ single directories), get all the `mbr` entries. (0)
#+ These should all:
#+   1. have more than one yes-binary-model classification
#+   2. for now, be in the Multiple_Binding_Reuse_Classes directory
#+   What else is allowed?
#+     2. 'fko', 'iac', and 'suh' can always be there
#+     3. 'abg' can be there
#+   What is not allowed?
#+     4. 'nbr', 'oic', 'mmx'
#+     5. None of these can be in the Multiple_Classes folder
#+     6. Just the 'mbr', alone


#  For any directory (the directory with everything sorted or any of the
#+ single directories), get all the `abg` entries. (0)
#+ These should all:
#+   1. Have at least one other classification
#+     What can these be?
#+
#+   What else is allowed?
#+     a. 'fko', 'iac', and 'suh' can always be there
#+     b. 
#+   What is not allowed?
#+     c. 
#+     d. Just the 'abg', alone





##########################################################################
########    MULTIPLE BINDING REUSE stuff
#+ For any directory (the directory with everything sorted or any of the
#+ single directories), get all the `mbr` entries. (point the 0th)
#+ With the underscores and legal classifications
$ find . -type f -iname "*.jpg" | \
    awk -F'/' '{print $NF}' | \
      grep -io "\(_[a-z]\{3\}\)\+[.]jpg$" | \
      sed 's#[.]jpg$##g' | \
        grep "mbr"
$ 
$
#+
#+




#  Which folders should always be empty after complete
Across_Book_Gutter_Reuse        (in the future, Across_Book_Gutter)









#  Let's think of all those that can't be alone
class    specific class that has to be there (but might not be the only one)     
--------+-------------------------------------------------------------------
abg
mbr
mcl
oic      nbr
mmx      nbr





####BEGIN <n>###########################################################
#  Let's think of all the illegal combinations 
#  (forget comment style for now)

mcl   nbr
      oic
      mmx
mbr   nbr
      oic
      mmx

abg   #<I guess noi would work here, but I'm not using that one in
      # this study.> 


# IF THERE'S NOT AN mbr
f25m3 f25m3 #  note that this is the case even if it's the same element
            #+ since we don't want it duplicated


####ENDOF <n>############### (illegal combinations) #####

#  Let's think of all the always-together combos (forget comment style for now)
      Pairs
      1. Those that cannot have other classifications (might not be any)
      
      2. Those that can only have the 'can always be there' (CABT): 
         'fko','iac','suh'
        Pairs
          oic nbr
            What else is legal with this pair (besides the CABT)
            a.
            b.
            What is illegal with this pair
            a. (too many)
          mmx nbr
            What else is legal with this pair (besides the CABT)
            a.
            b.
            What else is illegal with this pair
            a. too many
          
        Triplets (might not be any)
        
        Quartets or more (I doubt it)
        
      3. Those have, as their pair, one or more (all >0 must be possible)
         members of a class list (such as that seen in 'f25a3', 'f25m3'      
         and 'f25n3`)
        mbr f23m3(>1)
      



#################################################
##  OTHER USEFUL TIDBITS
##
# Finding the offending characters in filenames


## Maybe best.

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ ##    NEXT

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ cat files_to_rectify_1753973399_2025-07-31T084959-0600.list
# '.' is '/cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/'\
#'Classified_-_Almost_Just_3lett_FS_-_Combined'
./Connecting_or_Guard_Reuse/FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg
./Multiple_Binding_Reuse_Classes/Besançon Bibliothèqe Municiπale_-_color-MS¶0716_00122_mbr_ucr_orc.jpg
./Multiple_Binding_Reuse_Classes/FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg
./Multiple_Binding_Reuse_Classes/FamilySearch_-_DGS008279842_00131%fko_mbr_orc_ucr.jpg
./No_For_Binding_Reuse/BiblioþequesMediathequesDeMetz_-_Ms № 464_00092_0047B_oic_nbr.jpg
./No_For_Binding_Reuse/BnF-BiɓArsenal_-_Ms-87_00203_oic_nbr.jpg
./No_For_Binding_Reuse/Bodleian-Library?-MS-(AddAæ)-263°_00137_oic_nbr.jpg
./No_For_Binding_Reuse/FamilySearcℏ_-_DGS004763803_00695_oic_nbr.jpg
./No_For_Binding_Reuse/Family~Search_-_DGS005141812-ꝯ_00004_oic_nbr.jpg
./No_For_Binding_Reuse/FamilɤSearchɟ_—_DGS004321721&_00066@_oic_nbr.jpg
./No_For_Binding_Reuse/Leiden_-_DeSobrietate&BPL190_00052_nbr.jpg
./Outside_Cover_Reuse/UnivBologna-SistemaMusealed'Ateneo-AlmaMaterStudiorum_-_ErbarioAldrovandi-Vol-ᴠɪ-60001_orc.jpg
./Spine_Protection_Reuse/Heidelberg_-_'British quote marks'WappenlisteAebteSalem_salMsUnkn-1876_00001_spr.jpg
./Under_Cover_Reuse/FamilySearch_-_DGS102439140☞00014_ucr_suh_mcl.jpg

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "*æ*" | wc -l
0

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  That one has been completed

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Family*4763803*695*"
./No_For_Binding_Reuse/FamilySearcℏ_-_DGS004763803_00695_oic_nbr.jpg

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  Remember that directory.

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ ls No_For_Binding_Reuse/Family*4763803*695*
No_For_Binding_Reuse/FamilySearcℏ_-_DGS004763803_00695_oic_nbr.jpg

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  No quotes there.

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Family*4763803*695*" -print0 | xargs -I'{}' -0 printf "%q" {}
./No_For_Binding_Reuse/FamilySearcℏ_-_DGS004763803_00695_oic_nbr.jpg
bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  No quotes there, but following the pattern won't hurt.

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  Any non-ASCII characters or characters that are non-printable ASCII?

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Family*4763803*695*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]"
▒
▒
▒

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  -^- Helpful just in knowing some are there. We  grep-ped  for one byte

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #+ and any non-ASCII are 2+ bytes (in UTF-8)

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Family*4763803*695*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | wc -c # This will tell us the number of _bytes_, not generally the number of _characters_
3

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Family*4763803*695*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n'
ℏ
bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  Just a tofu on my terminal.

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Family*4763803*695*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##g;'
'ℏ'
bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Family*4763803*695*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | xxd
00000000: e284 8f                                  ...

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #
#  There's only one UTF-8 encoded character this time, but let's follow the
#+ pattern.

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  REMEMBER TO CHANGE THE `-iname' STRING if copying and pasting

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ ( find . -type f -iname "Family*4763803*695*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#\1.#g;' > my_tmp_bytes ) && while IFS= read line; do this_character="${line}"; printf "%s" "${line}" | xxd; done < <(sed 's#\n#--linefeed--#g' my_tmp_bytes | tr '.' '\n' | sed 's#--linefeed--#\n#g') && rm my_tmp_bytes
00000000: e284 8f                                  ...

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #
#  What I just did there tells me I should make it a function, or at least
#+ have a place to change the string at the beginning. (What I did there was
#+ to write the REMEMBER TO CHANGE ... STRING
#+ not to mention writing "copy ... paste")
#+
#+   (Actually, however, escaping the wildcards for the globbing would make 
#+    such a function quite difficult to get right.)

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #
#  We have just one character, on its own line. THIS IS NOT NECESSARY EVERY
#+ TIME, but to be more clear,

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  (REMEMBER TO CHANGE THE `-iname' STRING if copy/paste-ing)

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ ( find . -type f -iname "Family*4763803*695*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#\1.#g;' > my_tmp_bytes ) && while IFS= read line; do this_character="${line}"; printf "%s" "${line}" | xxd; done < <(sed 's#\n#--linefeed--#g' my_tmp_bytes | tr '.' '\n' | sed 's#--linefeed--#\n#g') | sed 's#^[0-9a-f]\+[:]##g; s#[^0-9a-f]##g; s#\(\(.\)\{2\}\)#\1 #g; s# $##g; s#^#0x#g; s#[ ]# 0x#g' && rm my_tmp_bytes
0xe2 0x84 0x8f

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #
#  There we go. One byte-encoded UTF-8 codepoint (glyph), which we
#+ often call a character. Don't do this every time, but checking ...

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ echo -e "\xe2\x84\x8f"
ℏ

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #
#  The tofu, again, hahaha, but copy/paste inside the terminal keeps the byte content.
#+ or ...

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ type getunicode4char
getunicode4char is a function
getunicode4char ()
{
    if [ "$@" = "-h" -o "$@" = "--help" ] 2> /dev/null; then
        echo "Help for getunicode4char:";
        echo;
        echo "Get the unicode codepoint representing the";
        echo "character given as input.";
        echo;
        echo "Requires: python3 for now, till I get the hexdump -C stuff finished";
        echo "It was originally built with Python 3 in mind, but it works";
        echo "without that, thanks to hexdump -C";
        echo "You'll still need to watch out for the problem strings";
        echo "methioned below.";
        echo;
        echo "Usage:";
        echo "% getunicode4char <string-with-one-character>";
        echo;
        echo "Examples:";
        echo "% getunicode4char <string-with-one-character>";
        echo;
        echo "Note that you might have to copy/paste the glyph of the";
        echo "character into some type of programmer's notebook with the";
        echo "encoding set as you want it (I want UTF-8). Then, in the";
        echo "notebook, write in the  getunicode4char  part as well as";
        echo "the quotes around the character.";
        echo;
        echo "It will be easier (less backslash escapes) if you use single";
        echo "quotes around the character you pass in. The only exception";
        echo "(for ASCII, at least), is the single quote. For that, use:";
        echo "% getunicode4char \"'\"";
        echo "Do note, however, that to get a return for the space character,";
        echo "You must escape it with a backslash, whether you surround it";
        echo "with single quotes, double quotes, or just put it in by itself.";
        echo " GOOD)% getunicode4char '\ '";
        echo ' GOOD)% getunicode4char "\ "';
        echo "      % #  This next one needs explaining. You should push the";
        echo "      % #+ Space Bar once after the backslash and then press the";
        echo "      % #+ Enter key.";
        echo " GOOD)% getunicode4char \ ";
        echo "--BAD)% getunicode4char ' '";
        echo '--BAD)% getunicode4char " "';
        echo;
        echo "If you really want to use double quotes, watch out for the";
        echo "following, which will not allow the program to continue -";
        echo "i.e. they will break the program.";
        echo "--BAD)% getunicode4char \"\\\"";
        echo " instead, use single quotes or";
        echo " GOOD)% getunicode4char \"\\\\\"";
        echo "--BAD)% getunicode4char \"\`\"";
        echo " instead, use single quotes or";
        echo " GOOD)% getunicode4char \"\\\`\"";
        echo "--BAD)% getunicode4char \"\"\"";
        echo " instead, use single quotes or";
        echo " GOOD)% getunicode4char \"\\\"\"";
    else
        if [ "$@" = "'" ]; then
            echo "U+0022";
        else
            if [ "$@" = "\"" ]; then
                echo "U+0028";
            else
                if [ "$@" = "\\" ]; then
                    echo "U+005c";
                else
                    python3_is_installed=0;
                    command -v python3 > /dev/null 2>&1 && python3_is_installed=1;
                    if [ $python3_is_installed -eq 1 ]; then
                        zeroX_str=$(python3 -c 'print(hex(ord('"'$@'"')))');
                        hex_only_str=$(echo "${zeroX_str}" | sed 's#0x##g');
                        while [ ${#hex_only_str} -lt 4 ]; do
                            hex_only_str="0${hex_only_str}";
                        done;
                        echo "U+${hex_only_str}";
                    else
                        echo "won't work for now. need python3";
                        return -1;
                    fi;
                fi;
            fi;
        fi;
    fi;
    return 0
}

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ echo -e "\xe2\x84\x8f"
ℏ

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ getunicode4char "$(!!)"
getunicode4char "$(echo -e "\xe2\x84\x8f")"
U+210f

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  Didn't even have to copy/paste the tofu, there.

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ echo -e "\u210f"
ℏ

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  tofu

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ echo -en "\u210f" | xxd
00000000: e284 8f                                  ...

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #
#  Anyway, <strike>in case there's not tofu,</strike> 
#+ the best display would be something that happened right under 
my first view of the tofu

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Family*4763803*695*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##g;'
'ℏ'
bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  That should be done even if there's tofu.

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #
#  Any of Dave's no-no ASCII characters?
#+ REMEMBER THE awk AND THE CHECK FOR SINGLE QUOTE/S, (')
#+ (that doesn't hint that I need a function, BTW)

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Family*4763803*695*" -print0 | xargs -I'{}' -0 printf "%q" {}  # Looking for a single quote. This also gives us the classification dir
./No_For_Binding_Reuse/FamilySearcℏ_-_DGS004763803_00695_oic_nbr.jpg
bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Bodl*MS*Add*263*137*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print $NF}'
Bodleian-Library-MS-Add-A-263_00137_oic_nbr.jpg

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #
#  -^- No (on-the-edge) single quote. If there were one, we'd just do
#+ a pipe to   sed 's#'"'"'$##g'   after the  awk  and before the  grep

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Bodl*MS*Add*263*137*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print $NF}' | grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']'

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Bodl*MS*Add*263*137*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print $NF}' | grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | wc -l
0

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  To be sure there are none:

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Bodl*MS*Add*263*137*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print $NF}' | grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | tr -d '\n' | wc -c  # would give us number of bytes, not generally the number of characters
0

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  Investigation of the filename validates our finding.

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #
#  Since I want this example to be a guide, I'm going to put in a heredoc
#+ with a previous filename's processing for Dave's no-nos

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ cat >/dev/null <<'EOF'

Here are the commands for another filename, where there were problems
in both checks (ASCII, Dave's no-no).

$ find . -type f -iname "Bodl*MS*Add*263*137*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print $NF}' | sed 's#^#'"'"'#g'
$ #  Note the lone single quote; you should remember the awk and the ' check
$ #  REMEMBER THE awk AND THE CHECK FOR SINGLE QUOTE(S), (')

$ find . -type f -iname "Bodl*MS*Add*263*137*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print $NF}' | sed 's#'"'"'$##g' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']'
?
(
)

$ find . -type f -iname "Bodl*MS*Add*263*137*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print $NF}' | sed 's#'"'"'$##g' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | tr -d '\n' | wc -c  # gives n_bytes, not generally n_characters
3

$ find . -type f -iname "Bodl*MS*Add*263*137*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print $NF}' | sed 's#'"'"'$##g' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | tr -d '\n'
?()

# (There actually won't be a blank line after the `?()'
$ #  This is the best view, the one to look at before changing the filename
$ #+ (if that be necessary).

#  Once again, no blank line, and I should start with -v-
#+ Wait, there will be a blank line.
$ find . -type f -iname "Bodl*MS*Add*263*137*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print $NF}' | sed 's#'"'"'$##g' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##g;'
'?', '(', ')'
$ #
#  Now, for both of the best views, after a view of the quoted
#+ filename, for reference before renaming.

$ find . -type f -iname "Bodl*MS*Add*263*137*" -print0 | xargs -I'{}' -0 printf "%q" {}
'./No_For_Binding_Reuse/Bodleian-Library?-MS-(AddAæ)-263°_00137_oic_nbr.jpg'
$  #  Non-ASCII and non-printable ASCII (control)

find . -type f -iname "Bodl*MS*Add*263*137*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##g;'
'æ', '°'
$ #  Dave's no-nos

$ find . -type f -iname "Bodl*MS*Add*263*137*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print $NF}' | sed 's#'"'"'$##g' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##g;'
'?', '(', ')'
#  Now, we can do the rename, after checks

EOF

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  For ours, here, we only have non-ASCII

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Family*4763803*695*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##g;'
'ℏ'
bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #
#  Now, we can rename.
#+  REMEMBER THE CLASSIFICATION DIRECTORY

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Family*4763803*695*" -print0 | xargs -I'{}' -0 printf "%q" {}
./No_For_Binding_Reuse/FamilySearcℏ_-_DGS004763803_00695_oic_nbr.jpg
bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Family*4763803*695*"
./No_For_Binding_Reuse/FamilySearcℏ_-_DGS004763803_00695_oic_nbr.jpg

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #
#  Luckily, they're the same in this case.
#+ Always use the one with  printf , by the way.

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #
#  Let's see if the fixed version somehow exists,
#+ first checking if we have an example of how other images from that
#+ document are named.

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Family*4763803*" | head -n 5
./No_For_Binding_Reuse/FamilySearch_-_DGS004763803_00225_oic_nbr.jpg
./No_For_Binding_Reuse/FamilySearch_-_DGS004763803_00226_oic_nbr.jpg
./No_For_Binding_Reuse/FamilySearch_-_DGS004763803_00227_oic_nbr.jpg
./No_For_Binding_Reuse/FamilySearcℏ_-_DGS004763803_00695_oic_nbr.jpg

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "FamilySearch_-_DGS004763803_00695_oic_nbr.jpg" | wc -l
0

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #
#  REMEMBER THE CLASSIFICATION DIRECTORY,
#+ be cautious by using `mv -i',
#+ and also make sure to check that the first (now-existing) file 
#+ will tab-complete.
#+ If there were single quotes in the `ls' version or the `%q' version,
#+ you'll likely need them (or backslash escapes) for the rename.

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ mv -i ./No_For_Binding_Reuse/FamilySearcℏ_-_DGS004763803_00695_oic_nbr.jpg ./No_For_Binding_Reuse/FamilySearch_-_DGS004763803_00695_oic_nbr.jpg  # the first filename tab-completed

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  Post-process checks

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "*.jpg" | wc -l
3331

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  good

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "Family*4763803*695*"
./No_For_Binding_Reuse/FamilySearch_-_DGS004763803_00695_oic_nbr.jpg

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  good

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ find . -type f -iname "*ℏ*" | wc -l
0

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ #  good

bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$ checksituation

 Current date/time is
Sat Aug  2 08:43:56 MDT 2025
1754145836
1754145836_2025-08-02T084356-0600

 Current directory ( pwd ) is
/cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined


bballdave025@MY-MACHINE /cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/Classified_-_Almost_Just_3lett_FS_-_Combined
$














###########################
# Example 1, without the (easier) piping-in of
# the found filename string.

#  If you don't take this from the filename string (piped-in from a `find` or something, you might just have to play around with escapes. This is especially true with quotes (single and double). It's not impossible, it just takes some knowledge of escaping.
#  Getting a quoted version (without piping-in)
$ printf "%q\n" 'FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg'
FamilySearch_-_DGS\ Бг҃ъ\ 008268002_00568_scg.jpg
$ #  -^- I can choose to use it with the single quotes or without quotes and with backslash space
$ echo 'FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg' | LC_ALL=C grep -P "[\x00-\x20\x7F-\xFF]"
FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg
$ #  -^- That's pretty useless in finding which character(s) is (are) causing the problem, but I'm putting it in to keep myself from doing useless things again.
$ echo 'FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg' | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]"

▒
▒
▒
▒
▒
▒
▒
▒

$ #  -^- Again, pretty useless, and piping it to  `cat' doesn't help.
$ #  Now, we start getting useful stuff
$ echo 'FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg' | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | wc -c # Note that this will be the total number of _bytes_, not necessarily characters. See the part with `xxd`
10
$ echo 'FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg' | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n'
 Бг҃ъ
$ echo 'FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg' | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##'
' ', 'Б', 'г', '҃', 'ъ', ' '
$ #  Note the weird stuff on the combining-character diacritic, there
$ echo 'FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg' | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | xxd
00000000: 20d0 91d0 b3d2 83d1 8a20                  ........
$ #
#  A more-complete (well, a more-able-to-tell-you-byte-by-byte what's illegal)
#+ version as found with the next file 
$ ( echo 'FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg' | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#\1.#g; s#.$##' > my_tmp_bytes ) && while IFS= read line; do this_character="${line}"; printf "%s" "${line}" | xxd; done < <(sed 's#\n#--linefeed--#g' my_tmp_bytes | tr '.' '\n' | sed 's#--linefeed--#\n#g') && rm my_tmp_bytes
00000000: 20
00000000: d091                                     ..
00000000: d0b3                                     ..
00000000: d283                                     ..
00000000: d18a                                     ..

$ #
#  By the way, the xxd which I have (which claims to be /usr/bin/xxd)
#+ outputs things in colors that make the byte boundaries somewhat more 
#+ obvious, but that's just with green spaces, yellow linefeeds and
#+ tabs, and who knows what else, but normal bytes next to each
#+ other are definitely not obviously separable




## DWB no-nos

$ echo 'FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | tr -d '\n' | wc -c
2
$ echo 'FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | tr -d '\n'
$ echo 'FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##'
' ', ' '
$ echo 'FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | tr -d '\n' | xxd
00000000: 2020
$ #  You can't see it, and it won't copy paste here, but `xxd` also spat out some other spaces, I'm not exactly sure what they mean, but they're there on my terminal (and should be there in my cleaned Lab Notebook log.



######################################################################
#  Now, the hardest one, with and without piping-in the filename.
#+ I re-created the file in an experimental directory

#  Piping-in the filename (I created the file again, in an experimental directory)
$ find . -type f -iname "FamilySearch=*"
./.for_experiment/FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg

$ #  -^- `find` gave us the unexpanded version.

$ ls .for_experiment/
'FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg'

$ #  -^- `ls` gave us the quoted version
$ find . -type f -iname "FamilySearch=*" -print0 | xargs -I'{}' -0 printf "%q" {}
'./.for_experiment/FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg'
$ find . -type f -iname "FamilySearch=*" -print0 | xargs -I'{}' -0 printf "%q\n" {}
'./.for_experiment/FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg'

$ find . -type f -iname "FamilySearch=*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]"
▒
▒

▒
▒

▒
▒
▒

▒
▒

$ #  -^- Pretty useless, here.

$ find . -type f -iname "FamilySearch=*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n'
ħ ̄ ⁊ ̄
$ #  -^- My terminal doesn't have all the necessary glyphs there, which is one reason xxd is nice to have

$ find . -type f -iname "FamilySearch=*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##'
'ħ', ' ', '̄', ' ', '⁊', ' ', '̄'
$ #  -^- More combining characters fun

$ find . -type f -iname "FamilySearch=*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | xxd
00000000: c4a7 20cc 8420 e281 8a20 cc84            .. .. ... ..

$ find . -type f -iname "FamilySearch=*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#\1.#g; s#.$##'  # It seems the last thing in this sed isn't needed.
ħ. .̄. .⁊. .̄
#$ #  This next one looks nice, BUT HAS A PROBLEM IF THERE IS A LINEFEED IN THE FILENAME
#
#$ ( find . -type f -iname "FamilySearch=*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#\1.#g; s#.$##' > my_tmp_bytes ) && while IFS= read line; do this_character="${line}"; printf "%s" "${line}" | xxd; done < <(tr '.' '\n' < my_tmp_bytes) && rm my_tmp_bytes
$ #  Now a better (but not fully tested) one

$ ( find . -type f -iname "FamilySearch=*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#\1.#g;' > my_tmp_bytes ) && while IFS= read line; do this_character="${line}"; printf "%s" "${line}" | xxd; done < <(sed 's#\n#--linefeed--#g' my_tmp_bytes | tr '.' '\n' | sed 's#--linefeed--#\n#g') && rm my_tmp_bytes
00000000: c4a7                                     ..
00000000: 20
00000000: cc84                                     ..
00000000: 20
00000000: e281 8a                                  ...
00000000: 20

$ #  If you want to go one or two or ... more,

$ ( find . -type f -iname "FamilySearch=*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#\1.#g;' > my_tmp_bytes ) && while IFS= read line; do this_character="${line}"; printf "%s" "${line}" | xxd; done < <(sed 's#\n#--linefeed--#g' my_tmp_bytes | tr '.' '\n' | sed 's#--linefeed--#\n#g') | sed 's#^[0-9a-f]\+[:]##g; s#[^0-9a-f]##g' && rm my_tmp_bytes
c4a7
20
cc84
20
e2818a
20

$ ( find . -type f -iname "FamilySearch=*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#\1.#g;' > my_tmp_bytes ) && while IFS= read line; do this_character="${line}"; printf "%s" "${line}" | xxd; done < <(sed 's#\n#--linefeed--#g' my_tmp_bytes | tr '.' '\n' | sed 's#--linefeed--#\n#g') | sed 's#^[0-9a-f]\+[:]##g; s#[^0-9a-f]##g; s#\(\(.\)\{2\}\)#\1 #g; s# $##g;' && rm my_tmp_bytes
c4 a7
20
cc 84
20
e2 81 8a
20

$ ( find . -type f -iname "FamilySearch=*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#\1.#g;' > my_tmp_bytes ) && while IFS= read line; do this_character="${line}"; printf "%s" "${line}" | xxd; done < <(sed 's#\n#--linefeed--#g' my_tmp_bytes | tr '.' '\n' | sed 's#--linefeed--#\n#g') | sed 's#^[0-9a-f]\+[:]##g; s#[^0-9a-f]##g; s#\(\(.\)\{2\}\)#\1 #g; s# $##g; s#^#0x#g; s#[ ]# 0x#g' && rm my_tmp_bytes
0xc4 0xa7
0x20
0xcc 0x84
0x20
0xe2 0x81 0x8a
0x20

$











#  Without piping in the filename.

$ printf '%q' 'FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg'
FamilySearch=\"iħm\ xp̄m\ ⁊\ dm̄\"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg
$ #
#  -^- I'll just use the single quoted version. (Without piping, it's case-by-case)
#+ except in the case that you still have the file, when you can use `ls` to get
#+ the quoted version, as I just found. However, the point of this was to figure
#+ things out when I don't have the filename.

$ cd .for_experiment/ && ls && cd ..
'FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg'

$ echo 'FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg' | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]"
▒
▒

▒
▒

▒
▒
▒

▒
▒

$ #  -^- Again, not too useful; piping to `cat' doesn't help.

$ #  Now, for useful stuff

$ #echo 'FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg' | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]"

$ #  This next one will give us the number of _bytes_ not the number of

$ #+ characters (glyphs, codepoints, ...)

$ echo 'FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg' | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | wc -c
12

$ echo 'FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg' | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n'
ħ ̄ ⁊ ̄
$ #  Looks familiar.

$ echo 'FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg' | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##'
'ħ', ' ', '̄', ' ', '⁊', ' ', '̄'
$ #  Combining characters!

$ echo 'FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg' | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | xxd
00000000: c4a7 20cc 8420 e281 8a20 cc84            .. .. ... ..

$ #  Just for fun, we'll go the one more step and see one codepoint's bytes

$ #+ per line.

$ ( echo 'FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg' | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#\1.#g; s#.$##' > my_tmp_bytes ) && while IFS= read line; do this_character="${line}"; printf "%s" "${line}" | xxd; done < <(sed 's#\n#--linefeed--#g' my_tmp_bytes | tr '.' '\n' | sed 's#--linefeed--#\n#g') && rm my_temp_bytes
00000000: c4a7                                     ..
00000000: 20
00000000: cc84                                     ..
00000000: 20
00000000: e281 8a                                  ...
00000000: 20
rm: cannot remove 'my_temp_bytes': No such file or directory

$ ( echo 'FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg' | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#\1.#g; s#.$##' > my_tmp_bytes ) && while IFS= read line; do this_character="${line}"; printf "%s" "${line}" | xxd; done < <(sed 's#\n#--linefeed--#g' my_tmp_bytes | tr '.' '\n' | sed 's#--linefeed--#\n#g') && rm my_tmp_bytes
00000000: c4a7                                     ..
00000000: 20
00000000: cc84                                     ..
00000000: 20
00000000: e281 8a                                  ...
00000000: 20

$ #  Now a command to show that we need to delete this experimental file

$ find . -type f -iname "*.jpg" | wc -l
3332

$ #  Oh no!  There's an extra.

$ rm -r .for_experiment/

$ find . -type f -iname "*.jpg" | wc -l
3331

$ #  From here, I'll just fix files as I go.
#+ And my alarm went off, meaning I'm supposed to check myself and
#+ see if what I'm doing is going towards the main goal, which it
#+ isn't. This is a going-to-far, TINN.


#  There are one or two things with the Dave's no-nos that are important in this next one.
#+ Okay, there were several more.

$ cat files_to_rectify_1753973399_2025-07-31T084959-0600.list
# '.' is '/cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/'\
#'Classified_-_Almost_Just_3lett_FS_-_Combined'
./Connecting_or_Guard_Reuse/FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg
./Multiple_Binding_Reuse_Classes/Besançon Bibliothèqe Municiπale_-_color-MS¶0716_00122_mbr_ucr_orc.jpg
./Multiple_Binding_Reuse_Classes/FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg
./Multiple_Binding_Reuse_Classes/FamilySearch_-_DGS008279842_00131%fko_mbr_orc_ucr.jpg
./No_For_Binding_Reuse/BiblioþequesMediathequesDeMetz_-_Ms № 464_00092_0047B_oic_nbr.jpg
./No_For_Binding_Reuse/BnF-BiɓArsenal_-_Ms-87_00203_oic_nbr.jpg
./No_For_Binding_Reuse/Bodleian-Library?-MS-(AddAæ)-263°_00137_oic_nbr.jpg
./No_For_Binding_Reuse/FamilySearcℏ_-_DGS004763803_00695_oic_nbr.jpg
./No_For_Binding_Reuse/Family~Search_-_DGS005141812-ꝯ_00004_oic_nbr.jpg
./No_For_Binding_Reuse/FamilɤSearchɟ_—_DGS004321721&_00066@_oic_nbr.jpg
./No_For_Binding_Reuse/Leiden_-_DeSobrietate&BPL190_00052_nbr.jpg
./Outside_Cover_Reuse/UnivBologna-SistemaMusealed'Ateneo-AlmaMaterStudiorum_-_ErbarioAldrovandi-Vol-ᴠɪ-60001_orc.jpg
./Spine_Protection_Reuse/Heidelberg_-_'British quote marks'WappenlisteAebteSalem_salMsUnkn-1876_00001_spr.jpg
./Under_Cover_Reuse/FamilySearch_-_DGS102439140☞00014_ucr_suh_mcl.jpg

$ find . -type f -iname "*Mediathe*"  # Should have used `head'
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00001_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00002_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00003_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00004_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00091_0047A_oic_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00118_0060B_fko_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00121_0062A_oic_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00733_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00734_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00735_nbr.jpg
./No_For_Binding_Reuse/BiblioþequesMediathequesDeMetz_-_Ms № 464_00092_0047B_oic_nbr.jpg
./Spine_Protection_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00736_spr_suh.jpg

$ find . -type f -iname "*Mediathe*464*92*"
./No_For_Binding_Reuse/BiblioþequesMediathequesDeMetz_-_Ms № 464_00092_0047B_oic_nbr.jpg

$ find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {}
'./No_For_Binding_Reuse/BiblioþequesMediathequesDeMetz_-_Ms № 464_00092_0047B_oic_nbr.jpg'
$ #  Non-ASCII (like the thorn, maybe?)

$ find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | wc -c
14

$ #  -^- That's the number of bytes, not generally of characters

$ find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]"
▒
▒

▒
▒
▒


$ #
#  Since any non-ASCII are at least 2 bytes, and grep is finding bytes,
#+ we see nonsense.

$ find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n'
þ №
$ #  thorn, space, and numero (maybe another space?)

$ find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##'
'þ', ' ', '№', ' '

$ #  Oh, wait, let's find the UTF-8 byte-encoding of those characters

$ ( find . -type f -iname "FamilySearch=*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#\1.#g; s#.$##' > my_tmp_bytes ) && while IFS= read line; do this_character="${line}"; printf "%s" "${line}" | xxd; done < <(sed 's#\n#--linefeed--#g' my_tmp_bytes | tr '.' '\n' | sed 's#--linefeed--#\n#g') | sed 's#^[0-9a-f]\+[:]##g; s#[^0-9a-f]##g; s#\(\(.\)\{2\}\)#\1 #g; s# $##g; s#^#0x#g; s#[ ]# 0x#g' && rm my_tmp_bytes

$ ( find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#\1.#g; s#.$##' > my_tmp_bytes ) && while IFS= read line; do this_character="${line}"; printf "%s" "${line}" | xxd; done < <(sed 's#\n#--linefeed--#g' my_tmp_bytes | tr '.' '\n' | sed 's#--linefeed--#\n#g') | sed 's#^[0-9a-f]\+[:]##g; s#[^0-9a-f]##g; s#\(\(.\)\{2\}\)#\1 #g; s# $##g; s#^#0x#g; s#[ ]# 0x#g' && rm my_tmp_bytes
0xc3 0xbe
0x20
0xe2 0x84 0x96

$ # Where's the last space?

$ ( find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#\1.#g; s#.$##' > my_tmp_bytes ) && while IFS= read line; do this_character="${line}"; printf "%s" "${line}" | xxd; done < <(sed 's#\n#--linefeed--#g' my_tmp_bytes | tr '.' '\n' | sed 's#--linefeed--#\n#g') && rm my_tmp_bytes
00000000: c3be                                     ..
00000000: 20
00000000: e284 96                                  ...

$ #  Not going to worry about it, now.

$ ( find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#\1.#g;' > my_tmp_bytes ) && while IFS= read line; do this_character="${line}"; printf "%s" "${line}" | xxd; done < <(sed 's#\n#--linefeed--#g' my_tmp_bytes | tr '.' '\n' | sed 's#--linefeed--#\n#g') && rm my_tmp_bytes
00000000: c3be                                     ..
00000000: 20
00000000: e284 96                                  ...
00000000: 20

$ #  Oh, wait; I found the last space.

$ #  Dave's no-nos

$ find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print $NF}' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']'


'

$ find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print $NF}' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | tr -d '\n'
  '
$ find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print $NF}' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##'
' ', ' ', '''
$ find . -type f -iname "*Mediathe*464*92*"
./No_For_Binding_Reuse/BiblioþequesMediathequesDeMetz_-_Ms № 464_00092_0047B_oic_nbr.jpg

$ #
#  The awk is cutting off the something quoted.  Tricky.  I need to look
#+ back to the output of `printf`

$ find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {}
'./No_For_Binding_Reuse/BiblioþequesMediathequesDeMetz_-_Ms № 464_00092_0047B_oic_nbr.jpg'
$ #
#  This would be difficult to automate, but not impossible.  Just look at
#+ cases with the first character.
#  I'm not going to automate, now, though.

$ find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print '"\"'\"' $NF}' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##'
bash: !@#: event not found

$ find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print "'"'"'" $NF}'
'BiblioþequesMediathequesDeMetz_-_Ms № 464_00092_0047B_oic_nbr.jpg'

$ #  There we go.

$ find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | awk -F'/' '{print "'"'"'" $NF}' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##'
''', ' ', ' ', '''
$ #
#  Okay. You just have to have seen that we have a single-quoted thingie.
#+ Wait, I think I can take care of this, maybe. I'm not sure how it will
#+ look further down the line, but let's look at it.

$ find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | sed 's#^'"'"'##g; s#'"'"'$##g' | awk -F'/' '{print $NF}' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##'
' ', ' '
$ #
#  Just seeing the spaces, now. If someone started their file with a single quote, there would likely be problems. No, I think the %q would put a " in front
#  Whatever; It gets me where I need to be.

$ #  Non-ASCII and non-printable (control) ASCII

$ find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##'
'þ', ' ', '№', ' '
$ #  Dave's no-nos

$ find . -type f -iname "*Mediathe*464*92*" -print0 | xargs -I'{}' -0 printf "%q" {} | sed 's#^'"'"'##g; s#'"'"'$##g' | awk -F'/' '{print $NF}' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']' | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##'
' ', ' '
$ find . -type f -iname "*Mediathe*464*92*"
./No_For_Binding_Reuse/BiblioþequesMediathequesDeMetz_-_Ms № 464_00092_0047B_oic_nbr.jpg

$ find . -type f -iname "BibliothequesMediathequesDeMetz_-_Ms464_00092_0047B_oic_nbr.jpg"

$ #  I don't know why I didn't have the e-accent-aigu in Mediatheques

$ find . -type f -iname "Bib*Med*Metz*464*"  # Again, should have used `head'
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00001_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00002_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00003_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00004_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00091_0047A_oic_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00118_0060B_fko_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00121_0062A_oic_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00733_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00734_nbr.jpg
./No_For_Binding_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00735_nbr.jpg
./No_For_Binding_Reuse/BiblioþequesMediathequesDeMetz_-_Ms № 464_00092_0047B_oic_nbr.jpg
./Spine_Protection_Reuse/BibliothequesMediathequesDeMetz_-_Ms464_00736_spr_suh.jpg

$ find . -type f -iname "BibliothequesMediathequesDeMetz_-_Ms464_00092_0047B_oic_nbr.jpg" | wc -l
0

$ mv './No_For_Binding_Reuse/BiblioþequesMediathequesDeMetz_-_Ms № 464_00092_0047B_oic_nbr.jpg' "BibliothequesMediathequesDeMetz_-_Ms464_00092_0047B_oic_nbr.jpg"

$ find . -type f -iname "*№*"

$ #  Good, gone.

$

























$ cat files_to_rectify_1753973399_2025-07-31T084959-0600.list
# '.' is '/cygdrive/c/David/FHTW-2025-All_-_move_2024_get_new/'\
#'Classified_-_Almost_Just_3lett_FS_-_Combined'
./Connecting_or_Guard_Reuse/FamilySearch_-_DGS Бг҃ъ 008268002_00568_scg.jpg
./Multiple_Binding_Reuse_Classes/Besançon Bibliothèqe Municiπale_-_color-MS¶0716_00122_mbr_ucr_orc.jpg
./Multiple_Binding_Reuse_Classes/FamilySearch="iħm xp̄m ⁊ dm̄"_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg
./Multiple_Binding_Reuse_Classes/FamilySearch_-_DGS008279842_00131%fko_mbr_orc_ucr.jpg
./No_For_Binding_Reuse/BiblioþequesMediathequesDeMetz_-_Ms № 464_00092_0047B_oic_nbr.jpg
./No_For_Binding_Reuse/BnF-BiɓArsenal_-_Ms-87_00203_oic_nbr.jpg
./No_For_Binding_Reuse/Bodleian-Library?-MS-(AddAæ)-263°_00137_oic_nbr.jpg
./No_For_Binding_Reuse/FamilySearcℏ_-_DGS004763803_00695_oic_nbr.jpg
./No_For_Binding_Reuse/Family~Search_-_DGS005141812-ꝯ_00004_oic_nbr.jpg
./No_For_Binding_Reuse/FamilɤSearchɟ_—_DGS004321721&_00066@_oic_nbr.jpg
./No_For_Binding_Reuse/Leiden_-_DeSobrietate&BPL190_00052_nbr.jpg
./Outside_Cover_Reuse/UnivBologna-SistemaMusealed'Ateneo-AlmaMaterStudiorum_-_ErbarioAldrovandi-Vol-ᴠɪ-60001_orc.jpg
./Spine_Protection_Reuse/Heidelberg_-_'British quote marks'WappenlisteAebteSalem_salMsUnkn-1876_00001_spr.jpg
./Under_Cover_Reuse/FamilySearch_-_DGS102439140☞00014_ucr_suh_mcl.jpg

$ find . -type f -iname "BnF-Bi*Arsenal*87*203*" | wc -l
1

$ find . -type f -iname "BnF-Bi*Arsenal*87*203*"
./No_For_Binding_Reuse/BnF-BiɓArsenal_-_Ms-87_00203_oic_nbr.jpg

$ find . -type f -iname "BnF*Arsenal*87*" | head -n 5
./Front-back_Matter_Reuse/BnF-BibArsenal_-_Ms-87_00738_fmr.jpg
./No_For_Binding_Reuse/BnF-BibArsenal_-_Ms-87_00003_fko_nbr.jpg
./No_For_Binding_Reuse/BnF-BibArsenal_-_Ms-87_00004_nbr.jpg
./No_For_Binding_Reuse/BnF-BibArsenal_-_Ms-87_00031_oic_nbr.jpg
./No_For_Binding_Reuse/BnF-BibArsenal_-_Ms-87_00129_mmx_nbr.jpg

$ find . -type f -iname "BnF-Bi*Arsenal*87*203*"
./No_For_Binding_Reuse/BnF-BiɓArsenal_-_Ms-87_00203_oic_nbr.jpg

$ find . -type f -iname "BnF-Bi*Arsenal*87*203*" | xargs -I'{}' -0 printf "%q" {}
'./No_For_Binding_Reuse/BnF-BiɓArsenal_-_Ms-87_00203_oic_nbr.jpg'$'\n'
$ #  I'm going to leave off the single quotes, just by inspection.

$ #  Non-ASCII or non-printable (control) ASCII

$ find . -type f -iname "BnF-Bi*Arsenal*87*203*" | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]"
▒
▒

$ #  Grepped for 1 byte, non-ASCII are 2 bytes or more

$ find . -type f -iname "BnF-Bi*Arsenal*87*203*" | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n'
ɓ
$ # Hooray! We have xxd (my terminal doesn't show that character.)

$ # Hooray! We have xxd | xxd

$ #  I left that last one in, because it's funny.

$ find . -type f -iname "BnF-Bi*Arsenal*87*203*" | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | xxd
00000000: c993                                     ..

$ #  Just one character.  Nice!  But let's be sure.

$ find . -type f -iname "BnF-Bi*Arsenal*87*203*" | LC_ALL=C grep -oP "[\x00-\x20\x7F-\xFF]" | tr -d '\n' | sed 's#\(.\)#'"'"'\1'"'"', #g; s#, $##'
'ɓ'

$ #  REMEMBER THE awk

$ find . -type f -iname "BnF-Bi*Arsenal*87*203*" | awk -F'/' '{print $NF}' | LC_ALL=C grep -o '[] ~!@#$%^&|\/)(}{[*?><;:"`'"'"']'

$ #  No problems there.  Hooray!

$ find . -type f -iname "BnF-Bi*Arsenal*87*203*"
./No_For_Binding_Reuse/BnF-BiɓArsenal_-_Ms-87_00203_oic_nbr.jpg

$ find . -type f -iname "BnF-BibArsenal_-_Ms-87_00203_oic_nbr.jpg" | wc -l
0

$ mv -i ./No_For_Binding_Reuse/BnF-BiɓArsenal_-_Ms-87_00203_oic_nbr.jpg "./No_For_Binding_Reuse/BnF-BibArsenal_-_Ms-87_00203_oic_nbr.jpg"

$ find . -maxdepth 1 -type f | wc -l
3

$ find . -maxdepth 1 -type f
./BibliothequesMediathequesDeMetz_-_Ms464_00092_0047B_oic_nbr.jpg
./FamilySearch_-_DGS004459005_00069_mbr_mcl_fmr_cwa.jpg
./files_to_rectify_1753973399_2025-07-31T084959-0600.list

$ #  Yeah, I didn't get the relative paths there.

$ mv ./BibliothequesMediathequesDeMetz_-_Ms464_00092_0047B_oic_nbr.jpg ./No_For_Binding_Reuse/

$ find . -type f -iname "*.jpg" | wc -l
3331







